---
title: QObject源码阅读笔记
author: 齐兆龙
date: 2025-09-20
category: Qt
layout: post
---

---

# qobject.h的QObjectData类
初看qobject.h，除了前向声明和一些模板，方法等，主要有两个类：QObjectData和QObject。主要贴下QObjectData：
## QObjectData
```cpp
class Q_CORE_EXPORT QObjectData {
    Q_DISABLE_COPY(QObjectData) //禁止拷贝
public:
    QObjectData() = default;    //默认构造函数
    virtual ~QObjectData() = 0; //纯虚析构函数
    QObject *q_ptr;             //qobject指针，指向公共接口，也就是拥有QObjectData的那个QObject
    QObject *parent;            //父对象指针
    QObjectList children;       //子对象列表

    uint isWidget : 1;
    uint blockSig : 1;
    uint wasDeleted : 1;
    uint isDeletingChildren : 1;
    uint sendChildEvents : 1;
    uint receiveChildEvents : 1;
    uint isWindow : 1; //for QWindow
    uint deleteLaterCalled : 1;
    uint unused : 24;
    int postedEvents;
    QDynamicMetaObjectData *metaObject;
    QMetaObject *dynamicMetaObject() const;

#ifdef QT_DEBUG
    enum { CheckForParentChildLoopsWarnDepth = 4096 };
#endif
};
```

# QObject的Pimpl（Pointer to Implementation）设计模式
QObject的实现原理是Pimpl，即实现细节隐藏，QObject的细节实现类是QObjectPrivate。但是在头文件并没有看的这个成员变量。Qt将其隐藏起来了。

仔细查阅才明白QObject、QObjectData和QObjectPrivate的关系：
QObjectData是稳定的二进制接口，里面的数据是不变的，而QObjectPrivate是可拓展的，继承QObjectData。而QObject有QObjectData指针。

这三者的关系有点绕，实际上就是Pimpl将私有实现分为了两个部分：QObjectData（稳定）和QObjectPrivate（变化）。但是我想为什么QObject不用直接的 QObjectPrivate指针呢？
问DeepSeek：
- **头文件依赖，如果用QObjectPrivate，那么有包含 qobject.h的文件都会间接包含qobject_p.h，导致编译时间爆炸性增长。**
- **二进制兼容，总结就是用QObjectData（基类）指针，QObject的内存大小固定，QObjectPrivate（派生类）变化不影响QObject的大小。**

如果要访问QObjectPrivate，那么可以用reinterpret_cast进行向下转换。**reinterpret_cast 中的 "reinterpret" 意思是重新解释。这个操作符的作用是：将一段内存的比特位重新解释为另一种类型，而不进行任何实际的转换或检查。虽然危险，但是确保安全的前提下获得了最大性能。**
```cpp
// qobject.h
class Q_CORE_EXPORT QObject
{
    Q_OBJECT

    Q_PROPERTY(QString objectName READ objectName WRITE setObjectName NOTIFY objectNameChanged)
    //这里面定义了访问QObjectPrivate的函数d_func()
    Q_DECLARE_PRIVATE(QObject)
    ...
    ...
// QObject中的QObjectData智能指针
protected:
    QScopedPointer<QObjectData> d_ptr;
    ...
    ...
};

// qglobal.h
template <typename T> inline T *qGetPtrHelper(T *ptr) { return ptr; }
template <typename Ptr> inline auto qGetPtrHelper(Ptr &ptr) -> decltype(ptr.operator->()) { return ptr.operator->(); }

// The body must be a statement:
#define Q_CAST_IGNORE_ALIGN(body) QT_WARNING_PUSH QT_WARNING_DISABLE_GCC("-Wcast-align") body QT_WARNING_POP
//##为C++宏定义语法，连接两个字符串;通过reinterpret_cast将QObjectData指针转换为Class##Private指针（即QObjectPrivate）。
#define Q_DECLARE_PRIVATE(Class) \
    inline Class##Private* d_func() \
    { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<Class##Private *>(qGetPtrHelper(d_ptr));) } \
    inline const Class##Private* d_func() const \
    { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<const Class##Private *>(qGetPtrHelper(d_ptr));) } \
    friend class Class##Private;

//目前还没看到在哪用到，不过作用类似
#define Q_DECLARE_PRIVATE_D(Dptr, Class) \
    inline Class##Private* d_func() \
    { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<Class##Private *>(qGetPtrHelper(Dptr));) } \
    inline const Class##Private* d_func() const \
    { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<const Class##Private *>(qGetPtrHelper(Dptr));) } \
    friend class Class##Private;

#define Q_DECLARE_PUBLIC(Class)                                    \
    inline Class* q_func() { return static_cast<Class *>(q_ptr); } \
    inline const Class* q_func() const { return static_cast<const Class *>(q_ptr); } \
    friend class Class;

//这两个宏很重要，Q_D提供了访问私有实现（QObjectPrivate）的接口，Q_Q提供访问公共接口（QObject）的接口
#define Q_D(Class) Class##Private * const d = d_func()
#define Q_Q(Class) Class * const q = q_func()

```


# QObject的构造函数
QObject有两个重载的构造函数：
```cpp
// qobject.h
QObject::QObject(QObject *parent)
    : QObject(*new QObjectPrivate, parent) //调用下面那个构造函数
{
}

QObject::QObject(QObjectPrivate &dd, QObject *parent)
    : d_ptr(&dd)    //
{
    Q_ASSERT_X(this != parent, Q_FUNC_INFO, "Cannot parent a QObject to itself");

    Q_D(QObject);
    d_ptr->q_ptr = this;
    // QObject的d_ptr指向堆上的QObjectPrivate对象
    // 断言保证父对象不能是自己
    // Q_D(QObject);展开为QObjectPrivate * const d = d_func();
    // QObjectPrivate的q_ptr指向这个QObject对象，完成双向指针关系

    auto threadData = (parent && !parent->thread()) ? parent->d_func()->threadData.loadRelaxed() : QThreadData::current();
    threadData->ref();
    d->threadData.storeRelaxed(threadData);
    //如果父对象存在，且父对象没有线程，则继承父对象的线程数据，否则使用当前线程数据
    //引用计数加1
    //存储线程数据
    //原子操作

    if (parent) {
        QT_TRY {
            if (!check_parent_thread(parent, parent ? parent->d_func()->threadData.loadRelaxed() : nullptr, threadData))
                parent = nullptr;
            if (d->isWidget) {
                if (parent) {
                    d->parent = parent; //QObjectPrivate设置父对象指针
                    d->parent->d_func()->children.append(this);   //父对象的QObjectPrivate添加子对象到列表
                }
                // no events sent here, this is done at the end of the QWidget constructor
            } else {
                setParent(parent);
            }
        } QT_CATCH(...) {
            threadData->deref();
            QT_RETHROW;
        }
    }

    //如果父对象存在，则检查是否在同一线程，Qt要求不能在不同于父对象的线程里创造子对象
    // 如果是QObject直接settParent，如果是QWidget则延迟处理，因为QWidget可能有其他的操作
    // 下面这些不用管
#if QT_VERSION < 0x60000
    qt_addObject(this);
#endif
    if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
        reinterpret_cast<QHooks::AddQObjectCallback>(qtHookData[QHooks::AddQObject])(this);
    Q_TRACE(QObject_ctor, this);
}

// qobject.cpp
// 总结：不能在不同于父对象的线程里创造子对象
static bool check_parent_thread(QObject *parent,
                                QThreadData *parentThreadData,
                                QThreadData *currentThreadData)
{
    if (parent && parentThreadData != currentThreadData) {
        QThread *parentThread = parentThreadData->thread.loadAcquire();
        QThread *currentThread = currentThreadData->thread.loadAcquire();
        qWarning("QObject: Cannot create children for a parent that is in a different thread.\n"
                 "(Parent is %s(%p), parent's thread is %s(%p), current thread is %s(%p)",
                 parent->metaObject()->className(),
                 parent,
                 parentThread ? parentThread->metaObject()->className() : "QThread",
                 parentThread,
                 currentThread ? currentThread->metaObject()->className() : "QThread",
                 currentThread);
        return false;
    }
    return true;
}
```
总结：构造函数主要做了以下几件事：

- 构造QOBjectPrivate
- QObject的d_ptr指向QOBjectPrivate对象
- 父对象证同测试
- QObjectPrivate的q_ptr指针指向this，完成双向指针关系
- 线程检查，不允许在不同于父对象的线程中创建子对象
- 设置父对象，以及将自己添加到父对象的children列表里


# QObject的析构函数
析构函数代码有多，主要做了以下几件事：
- 设置状态wasDeleted为true，解除信号阻塞，以便始终能够发出destroyed()
```cpp
    Q_D(QObject);
    d->wasDeleted = true;
    d->blockSig = 0; // unblock signals so we always emit destroyed()
```
- 检查是否有被共享指针管理，如果有则保证清除共享引用计数
```cpp
QtSharedPointer::ExternalRefCountData *sharedRefcount = d->sharedRefcount.loadRelaxed();
    if (sharedRefcount) {
        if (sharedRefcount->strongref.loadRelaxed() > 0) {
            qWarning("QObject: shared QObject was deleted directly. The program is malformed and may crash.");
            // but continue deleting, it's too late to stop anyway
        }

        // indicate to all QWeakPointers that this QObject has now been deleted
        sharedRefcount->strongref.storeRelaxed(0);
        if (!sharedRefcount->weakref.deref())
            delete sharedRefcount;
    }
```
- 只有不是widget，发送destroyed()信号
```cpp
if (!d->isWidget && d->isSignalConnected(0)) {
        emit destroyed(this);
    }
```
- 检查是否被QML引擎管理，如果是，则通知QML引擎该对象即将被销毁
```cpp
if (d->declarativeData) {
        if (static_cast<QAbstractDeclarativeDataImpl*>(d->declarativeData)->ownedByQml1) {
            if (QAbstractDeclarativeData::destroyed_qml1)
                QAbstractDeclarativeData::destroyed_qml1(d->declarativeData, this);
        } else {
            if (QAbstractDeclarativeData::destroyed)
                QAbstractDeclarativeData::destroyed(d->declarativeData, this);
        }
    }
```
- 断开所有接受器
```cpp
// disconnect all receivers
        int receiverCount = cd->signalVectorCount();
        for (int signal = -1; signal < receiverCount; ++signal) {
            QObjectPrivate::ConnectionList &connectionList = cd->connectionsForSignal(signal);

            while (QObjectPrivate::Connection *c = connectionList.first.loadRelaxed()) {
                Q_ASSERT(c->receiver.loadAcquire());

                QBasicMutex *m = signalSlotLock(c->receiver.loadRelaxed());
                bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
                if (c->receiver.loadAcquire()) {
                    cd->removeConnection(c);
                    Q_ASSERT(connectionList.first.loadRelaxed() != c);
                }
                if (needToUnlock)
                    m->unlock();
            }
        }
```
- 断开所有发送者
```cpp
/* Disconnect all senders:
         */
        while (QObjectPrivate::Connection *node = cd->senders) {
            Q_ASSERT(node->receiver.loadAcquire());
            QObject *sender = node->sender;
            // Send disconnectNotify before removing the connection from sender's connection list.
            // This ensures any eventual destructor of sender will block on getting receiver's lock
            // and not finish until we release it.
            sender->disconnectNotify(QMetaObjectPrivate::signal(sender->metaObject(), node->signal_index));
            QBasicMutex *m = signalSlotLock(sender);
            bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
            //the node has maybe been removed while the mutex was unlocked in relock?
            if (node != cd->senders) {
                // We hold the wrong mutex
                Q_ASSERT(needToUnlock);
                m->unlock();
                continue;
            }

            QObjectPrivate::ConnectionData *senderData = sender->d_func()->connections.loadRelaxed();
            Q_ASSERT(senderData);

            QtPrivate::QSlotObjectBase *slotObj = nullptr;
            if (node->isSlotObject) {
                slotObj = node->slotObj;
                node->isSlotObject = false;
            }

            senderData->removeConnection(node);
            if (needToUnlock)
                m->unlock();

            if (slotObj) {
                locker.unlock();
                slotObj->destroyIfLastRef();
                locker.relock();
            }
        }
```
- 删除所有子对象
```cpp
    if (!d->children.isEmpty())
        d->deleteChildren();
```
- 从父对象的children列表中删除自己
```cpp
    if (d->parent)        // remove it from parent object
        d->setParent_helper(nullptr);
```

**代码的具体细节先不深究，先掌握其脉络。**

# 信号和槽

# 事件系统

# 对象树

# 元对象系统
## QOBject设置属性
在QObject代码开头就用到了属性系统：
```cpp
Q_PROPERTY(QString objectName READ objectName WRITE setObjectName NOTIFY objectNameChanged)
```
要使用属性系统，必须继承QObject，而且在声明时用Q_PROPERTY宏。语法是：
```cpp
Q_PROPERTY(type name
           (READ getFunction [WRITE setFunction] |
            MEMBER memberName [(READ getFunction | WRITE setFunction)])
           [RESET resetFunction]
           [NOTIFY notifySignal]
           [REVISION int]
           [DESIGNABLE bool]
           [SCRIPTABLE bool]
           [STORED bool]
           [USER bool]
           [CONSTANT]
           [FINAL]
           [REQUIRED])
```
[]表示可选，getFunction和setFunction表示getter和setter函数，memberName表示成员变量，resetFunction表示重置函数，notifySignal表示通知信号，revision表示属性的版本，designable表示属性是否可设计，scriptable表示属性是否可脚本化，stored表示属性是否可存储，user表示属性是否是用户定义的，constant表示属性是否是常量，final表示属性是否是最终的，required表示属性是否是必须的。
举一个例子：
```cpp
class Widget : public QWidget
{
    Q_OBJECT
    //Q_PROPERTY(QString value1 READ value1 WRITE setValue1 NOTIFY value1Changed FINAL)
    Q_PROPERTY(int value2 MEMBER value2 READ getValue2 WRITE setValue2 NOTIFY value2Changed DESIGNABLE true FINAL)

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();

    void setValue2(int value){value2 = value;emit value2Changed(value);}
    int getValue2(){return value2;}

signals:
    void value2Changed(int);

private:
    Ui::Widget *ui;
    int value2  = 0;
};

//main
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    Widget w1;
    w1.setValue2(2);
    qDebug() << "w1-value2 = " << QString::number(w1.getValue2());
    w1.setProperty("value2", 100);
    qDebug() << "w1-value2 = " << QString::number(w1.property("value2").toInt());

    Widget w2;
    w2.setValue2(200);
    qDebug() << "w2-value2 = " << QString::number(w2.getValue2());
    w2.setProperty("value2", 2000);
    qDebug() << "w2-value2 = " << QString::number(w2.property("value2").toInt());

    w1.setProperty("value2", 500);
    qDebug() << "w1-value2 = " << QString::number(w1.property("value2").toInt());
    QMetaProperty value2 = w2.metaObject()->property(w2.metaObject()->indexOfProperty("value2"));
    qDebug() << value2.name();
    qDebug() << value2.typeName();

    return a.exec();
}

//输出：
// w1-value2 =  "2"
// w1-value2 =  "100"
// w2-value2 =  "200"
// w2-value2 =  "2000"
// w1-value2 =  "500"
// value2
// int
```
**具体官网有介绍。**


# 状态机框架

# 定时器

# 其他
## 三个宏定义
Q_DISABLE_COPY

Q_DISABLE_MOVE

Q_DISABLE_COPY_MOVE
```cpp
#define Q_DISABLE_COPY(Class) \
    Class(const Class &) = delete;\
    Class &operator=(const Class &) = delete;

#define Q_DISABLE_MOVE(Class) \
    Class(Class &&) = delete; \
    Class &operator=(Class &&) = delete;

#define Q_DISABLE_COPY_MOVE(Class) \
    Q_DISABLE_COPY(Class) \
    Q_DISABLE_MOVE(Class)
```
这三个宏定义感觉很不错，一般不允许copy和move通过删除或者声明为private，现在可以直接用Qt的这三个宏，不用手写。