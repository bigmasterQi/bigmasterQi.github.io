---
title: QObject源码阅读笔记
author: 齐兆龙
date: 2025-09-20
category: Qt
layout: post
---

---

# qobject.h的QObjectData类
初看qobject.h，除了前向声明和一些模板，方法等，主要有两个类：QObjectData和QObject。主要贴下QObjectData：
## QObjectData
```cpp
class Q_CORE_EXPORT QObjectData {
    Q_DISABLE_COPY(QObjectData) //禁止拷贝
public:
    QObjectData() = default;    //默认构造函数
    virtual ~QObjectData() = 0; //纯虚析构函数
    QObject *q_ptr;             //qobject指针，指向公共接口，也就是拥有QObjectData的那个QObject
    QObject *parent;            //父对象指针
    QObjectList children;       //子对象列表

    uint isWidget : 1;
    uint blockSig : 1;
    uint wasDeleted : 1;
    uint isDeletingChildren : 1;
    uint sendChildEvents : 1;
    uint receiveChildEvents : 1;
    uint isWindow : 1; //for QWindow
    uint deleteLaterCalled : 1;
    uint unused : 24;
    int postedEvents;
    QDynamicMetaObjectData *metaObject;
    QMetaObject *dynamicMetaObject() const;

#ifdef QT_DEBUG
    enum { CheckForParentChildLoopsWarnDepth = 4096 };
#endif
};
```

# QObject的Pimpl（Pointer to Implementation）设计模式
QObject的实现原理是Pimpl，即实现细节隐藏，QObject的细节实现类是QObjectPrivate。但是在头文件并没有看的这个成员变量。Qt将其隐藏起来了。

仔细查阅才明白QObject、QObjectData和QObjectPrivate的关系：
QObjectData是稳定的二进制接口，里面的数据是不变的，而QObjectPrivate是可拓展的，继承QObjectData。而QObject有QObjectData指针。

这三者的关系有点绕，实际上就是Pimpl将私有实现分为了两个部分：QObjectData（稳定）和QObjectPrivate（变化）。但是我想为什么QObject不用直接的 QObjectPrivate指针呢？
问DeepSeek：
- **头文件依赖，如果用QObjectPrivate，那么有包含 qobject.h的文件都会间接包含qobject_p.h，导致编译时间爆炸性增长。**
- **二进制兼容，总结就是用QObjectData（基类）指针，QObject的内存大小固定，QObjectPrivate（派生类）变化不影响QObject的大小。**

如果要访问QObjectPrivate，那么可以用reinterpret_cast进行向下转换。**reinterpret_cast 中的 "reinterpret" 意思是重新解释。这个操作符的作用是：将一段内存的比特位重新解释为另一种类型，而不进行任何实际的转换或检查。虽然危险，但是确保安全的前提下获得了最大性能。**
```cpp
// qobject.h
class Q_CORE_EXPORT QObject
{
    Q_OBJECT

    Q_PROPERTY(QString objectName READ objectName WRITE setObjectName NOTIFY objectNameChanged)
    //这里面定义了访问QObjectPrivate的函数d_func()
    Q_DECLARE_PRIVATE(QObject)
    ...
    ...
// QObject中的QObjectData智能指针
protected:
    QScopedPointer<QObjectData> d_ptr;
    ...
    ...
};

// qglobal.h
template <typename T> inline T *qGetPtrHelper(T *ptr) { return ptr; }
template <typename Ptr> inline auto qGetPtrHelper(Ptr &ptr) -> decltype(ptr.operator->()) { return ptr.operator->(); }

// The body must be a statement:
#define Q_CAST_IGNORE_ALIGN(body) QT_WARNING_PUSH QT_WARNING_DISABLE_GCC("-Wcast-align") body QT_WARNING_POP
//##为C++宏定义语法，连接两个字符串;通过reinterpret_cast将QObjectData指针转换为Class##Private指针（即QObjectPrivate）。
#define Q_DECLARE_PRIVATE(Class) \
    inline Class##Private* d_func() \
    { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<Class##Private *>(qGetPtrHelper(d_ptr));) } \
    inline const Class##Private* d_func() const \
    { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<const Class##Private *>(qGetPtrHelper(d_ptr));) } \
    friend class Class##Private;

//目前还没看到在哪用到，不过作用类似
#define Q_DECLARE_PRIVATE_D(Dptr, Class) \
    inline Class##Private* d_func() \
    { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<Class##Private *>(qGetPtrHelper(Dptr));) } \
    inline const Class##Private* d_func() const \
    { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<const Class##Private *>(qGetPtrHelper(Dptr));) } \
    friend class Class##Private;

#define Q_DECLARE_PUBLIC(Class)                                    \
    inline Class* q_func() { return static_cast<Class *>(q_ptr); } \
    inline const Class* q_func() const { return static_cast<const Class *>(q_ptr); } \
    friend class Class;

//这两个宏很重要，Q_D提供了访问私有实现（QObjectPrivate）的接口，Q_Q提供访问公共接口（QObject）的接口
#define Q_D(Class) Class##Private * const d = d_func()
#define Q_Q(Class) Class * const q = q_func()

```


# QObject的构造函数
QObject有两个重载的构造函数：
```cpp
// qobject.h
QObject::QObject(QObject *parent)
    : QObject(*new QObjectPrivate, parent) //调用下面那个构造函数
{
}

QObject::QObject(QObjectPrivate &dd, QObject *parent)
    : d_ptr(&dd)    //
{
    Q_ASSERT_X(this != parent, Q_FUNC_INFO, "Cannot parent a QObject to itself");

    Q_D(QObject);
    d_ptr->q_ptr = this;
    // QObject的d_ptr指向堆上的QObjectPrivate对象
    // 断言保证父对象不能是自己
    // Q_D(QObject);展开为QObjectPrivate * const d = d_func();
    // QObjectPrivate的q_ptr指向这个QObject对象，完成双向指针关系

    auto threadData = (parent && !parent->thread()) ? parent->d_func()->threadData.loadRelaxed() : QThreadData::current();
    threadData->ref();
    d->threadData.storeRelaxed(threadData);
    //如果父对象存在，且父对象没有线程，则继承父对象的线程数据，否则使用当前线程数据
    //引用计数加1
    //存储线程数据
    //原子操作

    if (parent) {
        QT_TRY {
            if (!check_parent_thread(parent, parent ? parent->d_func()->threadData.loadRelaxed() : nullptr, threadData))
                parent = nullptr;
            if (d->isWidget) {
                if (parent) {
                    d->parent = parent; //QObjectPrivate设置父对象指针
                    d->parent->d_func()->children.append(this);   //父对象的QObjectPrivate添加子对象到列表
                }
                // no events sent here, this is done at the end of the QWidget constructor
            } else {
                setParent(parent);
            }
        } QT_CATCH(...) {
            threadData->deref();
            QT_RETHROW;
        }
    }

    //如果父对象存在，则检查是否在同一线程，Qt要求不能在不同于父对象的线程里创造子对象
    // 如果是QObject直接settParent，如果是QWidget则延迟处理，因为QWidget可能有其他的操作
    // 下面这些不用管
#if QT_VERSION < 0x60000
    qt_addObject(this);
#endif
    if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
        reinterpret_cast<QHooks::AddQObjectCallback>(qtHookData[QHooks::AddQObject])(this);
    Q_TRACE(QObject_ctor, this);
}

// qobject.cpp
// 总结：不能在不同于父对象的线程里创造子对象
static bool check_parent_thread(QObject *parent,
                                QThreadData *parentThreadData,
                                QThreadData *currentThreadData)
{
    if (parent && parentThreadData != currentThreadData) {
        QThread *parentThread = parentThreadData->thread.loadAcquire();
        QThread *currentThread = currentThreadData->thread.loadAcquire();
        qWarning("QObject: Cannot create children for a parent that is in a different thread.\n"
                 "(Parent is %s(%p), parent's thread is %s(%p), current thread is %s(%p)",
                 parent->metaObject()->className(),
                 parent,
                 parentThread ? parentThread->metaObject()->className() : "QThread",
                 parentThread,
                 currentThread ? currentThread->metaObject()->className() : "QThread",
                 currentThread);
        return false;
    }
    return true;
}
```
总结：构造函数主要做了以下几件事：

- 构造QOBjectPrivate
- QObject的d_ptr指向QOBjectPrivate对象
- 父对象证同检查
- QObjectPrivate的q_ptr指针指向this，完成双向指针关系
- 线程检查，不允许在不同于父对象的线程中创建子对象
- 设置父对象，以及将自己添加到父对象的children列表里


# QObject的析构函数
析构函数代码有多，主要做了以下几件事：
- 设置状态wasDeleted为true，解除信号阻塞，以便始终能够发出destroyed()
```cpp
    Q_D(QObject);
    d->wasDeleted = true;
    d->blockSig = 0; // unblock signals so we always emit destroyed()
```
- 检查是否有被共享指针管理，如果有则保证清除共享引用计数
```cpp
QtSharedPointer::ExternalRefCountData *sharedRefcount = d->sharedRefcount.loadRelaxed();
    if (sharedRefcount) {
        if (sharedRefcount->strongref.loadRelaxed() > 0) {
            qWarning("QObject: shared QObject was deleted directly. The program is malformed and may crash.");
            // but continue deleting, it's too late to stop anyway
        }

        // indicate to all QWeakPointers that this QObject has now been deleted
        sharedRefcount->strongref.storeRelaxed(0);
        if (!sharedRefcount->weakref.deref())
            delete sharedRefcount;
    }
```
- 只有不是widget，发送destroyed()信号
```cpp
if (!d->isWidget && d->isSignalConnected(0)) {
        emit destroyed(this);
    }
```
- 检查是否被QML引擎管理，如果是，则通知QML引擎该对象即将被销毁
```cpp
if (d->declarativeData) {
        if (static_cast<QAbstractDeclarativeDataImpl*>(d->declarativeData)->ownedByQml1) {
            if (QAbstractDeclarativeData::destroyed_qml1)
                QAbstractDeclarativeData::destroyed_qml1(d->declarativeData, this);
        } else {
            if (QAbstractDeclarativeData::destroyed)
                QAbstractDeclarativeData::destroyed(d->declarativeData, this);
        }
    }
```
- 断开所有接受器
```cpp
// disconnect all receivers
        int receiverCount = cd->signalVectorCount();
        for (int signal = -1; signal < receiverCount; ++signal) {
            QObjectPrivate::ConnectionList &connectionList = cd->connectionsForSignal(signal);

            while (QObjectPrivate::Connection *c = connectionList.first.loadRelaxed()) {
                Q_ASSERT(c->receiver.loadAcquire());

                QBasicMutex *m = signalSlotLock(c->receiver.loadRelaxed());
                bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
                if (c->receiver.loadAcquire()) {
                    cd->removeConnection(c);
                    Q_ASSERT(connectionList.first.loadRelaxed() != c);
                }
                if (needToUnlock)
                    m->unlock();
            }
        }
```
- 断开所有发送者
```cpp
/* Disconnect all senders:
         */
        while (QObjectPrivate::Connection *node = cd->senders) {
            Q_ASSERT(node->receiver.loadAcquire());
            QObject *sender = node->sender;
            // Send disconnectNotify before removing the connection from sender's connection list.
            // This ensures any eventual destructor of sender will block on getting receiver's lock
            // and not finish until we release it.
            sender->disconnectNotify(QMetaObjectPrivate::signal(sender->metaObject(), node->signal_index));
            QBasicMutex *m = signalSlotLock(sender);
            bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
            //the node has maybe been removed while the mutex was unlocked in relock?
            if (node != cd->senders) {
                // We hold the wrong mutex
                Q_ASSERT(needToUnlock);
                m->unlock();
                continue;
            }

            QObjectPrivate::ConnectionData *senderData = sender->d_func()->connections.loadRelaxed();
            Q_ASSERT(senderData);

            QtPrivate::QSlotObjectBase *slotObj = nullptr;
            if (node->isSlotObject) {
                slotObj = node->slotObj;
                node->isSlotObject = false;
            }

            senderData->removeConnection(node);
            if (needToUnlock)
                m->unlock();

            if (slotObj) {
                locker.unlock();
                slotObj->destroyIfLastRef();
                locker.relock();
            }
        }
```
- 删除所有子对象
```cpp
    if (!d->children.isEmpty())
        d->deleteChildren();
```
- 从父对象的children列表中删除自己
```cpp
    if (d->parent)        // remove it from parent object
        d->setParent_helper(nullptr);
```

**代码的具体细节先不深究，先掌握其脉络。**

# 信号和槽
之前我用的是Qt4的版本，信号槽的两个宏我想看下：

```cpp
Q_CORE_EXPORT const char *qFlagLocation(const char *method);

#ifndef QT_NO_META_MACROS
#ifndef QT_NO_DEBUG
# define QLOCATION "\0" __FILE__ ":" QT_STRINGIFY(__LINE__)
# ifndef QT_NO_KEYWORDS
#  define METHOD(a)   qFlagLocation("0"#a QLOCATION)
# endif
# define SLOT(a)     qFlagLocation("1"#a QLOCATION)
# define SIGNAL(a)   qFlagLocation("2"#a QLOCATION)
#else
# ifndef QT_NO_KEYWORDS
#  define METHOD(a)   "0"#a
# endif
# define SLOT(a)     "1"#a
# define SIGNAL(a)   "2"#a
#endif
```
上面是调试模式，下面是发布模式。调试模式多一些调试信息，本质就是：
- 前面加"0"表示普通方法，"1"表示槽，"2"表示信号。

- SLOT和SIGNAL宏，就是将方法名加上前缀拼接在一起。

信号槽主要有下面的这些接口（只贴常用的）：
```cpp
    //Qt4版本的信号槽，可以看到signal和slot都是char类型，例如：
    //connect(ui->button, SIGNAL(clicked()), this, SLOT(onClicked()));
    static QMetaObject::Connection connect(const QObject *sender, const char *signal,
                        const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection);

    //将信号连接到指向QObject成员函数的指针，例如：
    //connect(ui->button, &QPushButton::clicked, this, &MainWindow::onClicked);
    template <typename Func1, typename Func2>
    static inline QMetaObject::Connection connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal,
                                     const typename QtPrivate::FunctionPointer<Func2>::Object *receiver, Func2 slot,
                                     Qt::ConnectionType type = Qt::AutoConnection)
    {
        typedef QtPrivate::FunctionPointer<Func1> SignalType;
        typedef QtPrivate::FunctionPointer<Func2> SlotType;

        Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value,
                          "No Q_OBJECT in the class with the signal");

        //compilation error if the arguments does not match.
        Q_STATIC_ASSERT_X(int(SignalType::ArgumentCount) >= int(SlotType::ArgumentCount),
                          "The slot requires more arguments than the signal provides.");
        Q_STATIC_ASSERT_X((QtPrivate::CheckCompatibleArguments<typename SignalType::Arguments, typename SlotType::Arguments>::value),
                          "Signal and slot arguments are not compatible.");
        Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible<typename SlotType::ReturnType, typename SignalType::ReturnType>::value),
                          "Return type of the slot is not compatible with the return type of the signal.");

        const int *types = nullptr;
        if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
            types = QtPrivate::ConnectionTypes<typename SignalType::Arguments>::types();

        return connectImpl(sender, reinterpret_cast<void **>(&signal),
                           receiver, reinterpret_cast<void **>(&slot),
                           new QtPrivate::QSlotObject<Func2, typename QtPrivate::List_Left<typename SignalType::Arguments, SlotType::ArgumentCount>::Value,
                                           typename SignalType::ReturnType>(slot),
                            type, types, &SignalType::Object::staticMetaObject);
    }

    //连接到一个函数指针（不是成员），例如：
    //void globalHandler() { /*...*/ }
    //connect(ui->button, &QPushButton::clicked, globalHandler);
    template <typename Func1, typename Func2>
    static inline typename std::enable_if<int(QtPrivate::FunctionPointer<Func2>::ArgumentCount) >= 0, QMetaObject::Connection>::type
            connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, Func2 slot)
    {
        return connect(sender, signal, sender, slot, Qt::DirectConnection);
    }

    //连接到一个函数指针（不是成员），例如：
    //void globalHandler() { /*...*/ }
    //connect(ui->button, &QPushButton::clicked, this, globalHandler);
    template <typename Func1, typename Func2>
    static inline typename std::enable_if<int(QtPrivate::FunctionPointer<Func2>::ArgumentCount) >= 0 &&
                                          !QtPrivate::FunctionPointer<Func2>::IsPointerToMemberFunction, QMetaObject::Connection>::type
            connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, const QObject *context, Func2 slot,
                    Qt::ConnectionType type = Qt::AutoConnection)
    {
        typedef QtPrivate::FunctionPointer<Func1> SignalType;
        typedef QtPrivate::FunctionPointer<Func2> SlotType;

        Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value,
                          "No Q_OBJECT in the class with the signal");

        //compilation error if the arguments does not match.
        Q_STATIC_ASSERT_X(int(SignalType::ArgumentCount) >= int(SlotType::ArgumentCount),
                          "The slot requires more arguments than the signal provides.");
        Q_STATIC_ASSERT_X((QtPrivate::CheckCompatibleArguments<typename SignalType::Arguments, typename SlotType::Arguments>::value),
                          "Signal and slot arguments are not compatible.");
        Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible<typename SlotType::ReturnType, typename SignalType::ReturnType>::value),
                          "Return type of the slot is not compatible with the return type of the signal.");

        const int *types = nullptr;
        if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
            types = QtPrivate::ConnectionTypes<typename SignalType::Arguments>::types();

        return connectImpl(sender, reinterpret_cast<void **>(&signal), context, nullptr,
                           new QtPrivate::QStaticSlotObject<Func2,
                                                 typename QtPrivate::List_Left<typename SignalType::Arguments, SlotType::ArgumentCount>::Value,
                                                 typename SignalType::ReturnType>(slot),
                           type, types, &SignalType::Object::staticMetaObject);
    }

    /*连接到Functor/Lambda表达式，例如：
    connect(ui->button, &QPushButton::clicked, [this](){
        this->doSomething();
    });
    */
    template <typename Func1, typename Func2>
    static inline typename std::enable_if<QtPrivate::FunctionPointer<Func2>::ArgumentCount == -1, QMetaObject::Connection>::type
            connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, Func2 slot)
    {
        return connect(sender, signal, sender, std::move(slot), Qt::DirectConnection);
    }

    /*连接到Functor/Lambda表达式，例如：
    connect(ui->button, &QPushButton::clicked, this, [this](){
        this->doSomething();
    });
    */
    template <typename Func1, typename Func2>
    static inline typename std::enable_if<QtPrivate::FunctionPointer<Func2>::ArgumentCount == -1, QMetaObject::Connection>::type
            connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, const QObject *context, Func2 slot,
                    Qt::ConnectionType type = Qt::AutoConnection)
    {
        typedef QtPrivate::FunctionPointer<Func1> SignalType;
        const int FunctorArgumentCount = QtPrivate::ComputeFunctorArgumentCount<Func2 , typename SignalType::Arguments>::Value;

        Q_STATIC_ASSERT_X((FunctorArgumentCount >= 0),
                          "Signal and slot arguments are not compatible.");
        const int SlotArgumentCount = (FunctorArgumentCount >= 0) ? FunctorArgumentCount : 0;
        typedef typename QtPrivate::FunctorReturnType<Func2, typename QtPrivate::List_Left<typename SignalType::Arguments, SlotArgumentCount>::Value>::Value SlotReturnType;

        Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible<SlotReturnType, typename SignalType::ReturnType>::value),
                          "Return type of the slot is not compatible with the return type of the signal.");

        Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value,
                          "No Q_OBJECT in the class with the signal");

        const int *types = nullptr;
        if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
            types = QtPrivate::ConnectionTypes<typename SignalType::Arguments>::types();

        return connectImpl(sender, reinterpret_cast<void **>(&signal), context, nullptr,
                           new QtPrivate::QFunctorSlotObject<Func2, SlotArgumentCount,
                                typename QtPrivate::List_Left<typename SignalType::Arguments, SlotArgumentCount>::Value,
                                typename SignalType::ReturnType>(std::move(slot)),
                           type, types, &SignalType::Object::staticMetaObject);
    }                
```
总结下来：
- Qt4旧时代的连接，需要用宏SLOT和SIGNAL包裹
- 连接指向QObject的成员函数指针
- 连接到普通函数指针，没有上下文，默认receiver为sender
- 连接到普通函数指针，有上下文，即receiver可指定
- 连接到Functor/Lambda表达式，没有上下文，默认receiver为sender
- 连接到Functor/Lambda表达式，有上下文，即receiver可指定

## connect的Qt4版本

## connect的模板版本
### FunctionPointer - 特征提取器
```cpp
    /*
    FunctionPointer<Func> 结构是一个用于函数指针的类型特性。
    - ArgumentCount 是参数的数量，如果未知则为 -1
    - Object 类型定义是指向成员函数的指针的对象
    - Arguments 类型定义是参数列表（在 QtPrivate::List 中）
    - Function 类型定义是模板参数 Func 的别名
    - call<Args, R>(f, o, args) 方法用于调用该槽函数
        Args 是信号的参数列表
        R 是信号的返回类型f 是函数指针
        o 是接收者对象
        args 是指向参数的指针数组，如在 qt_metacall 中使用
    Functor<Func, N> 结构是调用 N 个参数的函数对象的助手。它的调用函数与 FunctionPointer::call 函数相同。
    */
    template<class Obj, typename Ret, typename... Args> struct FunctionPointer<Ret (Obj::*) (Args...)>
    {
        typedef Obj Object;// 提取类类型
        typedef List<Args...>  Arguments;// 提取参数列表
        typedef Ret ReturnType;// 提取返回类型
        typedef Ret (Obj::*Function) (Args...);//等同于using Function = Ret (Obj::*)(Args...)，表示Function是一个成员函数指针类型
        enum {ArgumentCount = sizeof...(Args), IsPointerToMemberFunction = true};
        // 生成统一调用接口
        template <typename SignalArgs, typename R>
        static void call(Function f, Obj *o, void **arg) {
            // 委托给FunctorCall具体执行
            FunctorCall<typename Indexes<ArgumentCount>::Value, SignalArgs, R, Function>::call(f, o, arg);
        }
    };
```
FunctionPointer是一个函数特征提取器，它通过模板特化机制分析函数签名，提取关键信息包括：所属类、返回类型、参数列表以及函数类型等，并将这些信息保存为类型别名和枚举值。同时，它生成一个统一的call回调模板函数，为后续的泛化调用提供接口。

在调用FunctorCall之前，需要通过Indexes<ArgumentCount>::Value生成一个编译时的索引序列。这个过程的核心是生成从0到ArgumentCount-1的整数序列（如 IndexesList<0,1,2>），为后续的参数展开提供位置索引。

这里采用分治策略而非简单循环的原因在于编译期计算的约束：编译期没有循环语句可用，只能通过递归实现，而分治算法将递归深度从O(N)优化到O(logN)，避免了编译器递归深度限制的问题。具体来说，算法将序列生成任务拆分为两个子序列（N/2 和 N-N/2），分别递归生成后再进行合并，通过偏移计算确保索引连续性。

### FunctorCall - 代码生成器
```cpp
    template <int... II, typename... SignalArgs, typename R, typename... SlotArgs, typename SlotRet, class Obj>
    struct FunctorCall<IndexesList<II...>, List<SignalArgs...>, R, SlotRet (Obj::*)(SlotArgs...)> {
        static void call(SlotRet (Obj::*f)(SlotArgs...), Obj *o, void **arg) {
            (o->*f)((*reinterpret_cast<typename RemoveRef<SignalArgs>::Type *>(arg[II+1]))...), ApplyReturnValue<R>(arg[0]);
        }
    };
```
FunctorCall是代码生成器，在调用时候根据参数模板实例化，再调用实际的函数指针f，类似：

(obj->*func)(
    *reinterpret_cast<int*>(arg[1]),     // II=0 → arg[0+1]
    *reinterpret_cast<double*>(arg[2])   // II=1 → arg[1+1]
);
这里面关键点是：SlotRet (Obj::*)(SlotArgs...)是一个函数类型，而SlotRet (Obj::*f)(SlotArgs...)是指该类似的函数f；arg[0]是返回值，arg[1]是参数1，arg[2]是参数2...展开后就是平时我们声明的函数的样子了；而SignalArgs和R既不是FunctionPointer也不是FunctorCall定义的，而是在外部调用的时候传进来的。


### QSlotObject - 槽对象
```cpp
        return connectImpl(sender, reinterpret_cast<void **>(&signal),
                           receiver, reinterpret_cast<void **>(&slot),
                           new QtPrivate::QSlotObject<Func2, typename QtPrivate::List_Left<typename SignalType::Arguments, SlotType::ArgumentCount>::Value,
                                           typename SignalType::ReturnType>(slot),
                            type, types, &SignalType::Object::staticMetaObject);
```
在调用connectImpl的时候，会生成一个QSlotObject对象，按照字面意思应该是包裹槽函数的对象；先看下这个宏做了什么
```cpp
    template <typename...> struct List {};
    template <typename Head, typename... Tail> struct List<Head, Tail...> { typedef Head Car; typedef List<Tail...> Cdr; };
    template <typename, typename> struct List_Append;
    template <typename... L1, typename...L2> struct List_Append<List<L1...>, List<L2...>> { typedef List<L1..., L2...> Value; };
    template <typename L, int N> struct List_Left {
        typedef typename List_Append<List<typename L::Car>,typename List_Left<typename L::Cdr, N - 1>::Value>::Value Value;
    };
```

这段代码主要做下几步：
- 定义空列表
- 定义一个列表包括：第一个元素 + 剩余列表
- 定义列表合并操作
- 定义List_Left为取列表L中的前N个元素：递归，将第一个元素加入到列表里直至空列表

```cpp
typename QtPrivate::List_Left<typename SignalType::Arguments, SlotType::ArgumentCount>::Value
```
对于上述代码，实际上就是取信号参数列表的前(槽函数的参数个数)，这就是信号的参数可以大于等于槽的参数，但是不能小于。
```cpp
    // 包含调用由函数指针管理的插槽所需函数的内部基类（接口）。
    class QSlotObjectBase {
        QAtomicInt m_ref;
        // 在这里不要使用虚函数；我们不希望编译器创建我们永远不会需要的大量每个多态类的东西。我们只使用一个函数指针。
        typedef void (*ImplFn)(int which, QSlotObjectBase* this_, QObject *receiver, void **args, bool *ret);
        const ImplFn m_impl;
    protected:
        enum Operation {
            Destroy,
            Call,
            Compare,

            NumOperations
        };
    public:
        explicit QSlotObjectBase(ImplFn fn) : m_ref(1), m_impl(fn) {}

        inline int ref() noexcept { return m_ref.ref(); }
        inline void destroyIfLastRef() noexcept
        { if (!m_ref.deref()) m_impl(Destroy, this, nullptr, nullptr, nullptr); }

        inline bool compare(void **a) { bool ret = false; m_impl(Compare, this, nullptr, a, &ret); return ret; }
        inline void call(QObject *r, void **a)  { m_impl(Call,    this, r, a, nullptr); }
    protected:
        ~QSlotObjectBase() {}
    private:
        Q_DISABLE_COPY_MOVE(QSlotObjectBase)
    };

    // QSlotObjectBase的实现，其中slot是指向QObject成员函数的指针。Args和R是与slot连接的信号的参数列表和返回类型。
    template<typename Func, typename Args, typename R> class QSlotObject : public QSlotObjectBase
    {
        typedef QtPrivate::FunctionPointer<Func> FuncType;
        Func function;
        static void impl(int which, QSlotObjectBase *this_, QObject *r, void **a, bool *ret)
        {
            switch (which) {
            case Destroy:
                delete static_cast<QSlotObject*>(this_);
                break;
            case Call:
                FuncType::template call<Args, R>(static_cast<QSlotObject*>(this_)->function, static_cast<typename FuncType::Object *>(r), a);
                break;
            case Compare:
                *ret = *reinterpret_cast<Func *>(a) == static_cast<QSlotObject*>(this_)->function;
                break;
            case NumOperations: ;
            }
        }
    public:
        explicit QSlotObject(Func f) : QSlotObjectBase(&impl), function(f) {}
    };
```
这段设计非常秒，QSlotObject类里有函数提起器、Function以及静态的函数指针。目前单看，QSlotObjectBase提供接口，QSLotObject实现细节；用函数指针+switch代替虚函数，节省空间和提高效率。                                        

### connectImpl - connect的内部实现
```cpp
/*
connect 模板版本的实现

sender              是发送者对象
signal              是指向发送方成员信号的指针
receiver            是接收对象，可能不是 \nullptr，当连接到静态函数或函子的时候为sender
slot                仅在使用 Qt：：UniqueConnection 时使用的指针
type                Qt：：ConnectionType 作为参数传递给连接
types               键入具有信号参数元类型 ID 的整数数组与排队连接一起使用必须至少在整个连接期间保持有效，则此功能不要拥有所有权。
                    通常是静态数据。
                    如果是 \nullptr，则当信号在队列中发出时将计算类型从签名中的类型连接。
senderMetaObject    是用于查找信号的元对象，信号必须位于
这个元对象
*/
QMetaObject::Connection QObject::connectImpl(const QObject *sender, void **signal,
                                             const QObject *receiver, void **slot,
                                             QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type,
                                             const int *types, const QMetaObject *senderMetaObject)
{
    if (!signal) {
        qWarning("QObject::connect: invalid nullptr parameter");
        if (slotObj)
            slotObj->destroyIfLastRef();
        return QMetaObject::Connection();
    }

    int signal_index = -1;
    void *args[] = { &signal_index, signal };
    for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
        senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
        if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
            break;
    }
    if (!senderMetaObject) {
        qWarning("QObject::connect: signal not found in %s", sender->metaObject()->className());
        slotObj->destroyIfLastRef();
        return QMetaObject::Connection(nullptr);
    }
    signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
    return QObjectPrivate::connectImpl(sender, signal_index, receiver, slot, slotObj, type, types, senderMetaObject);
}

/*!
    \internal

    Internal version of connect used by the template version of QObject::connect (called via connectImpl) and
    also used by the QObjectPrivate::connect version used by QML. The signal_index is expected to be relative
    to the number of signals.
 */
QMetaObject::Connection QObjectPrivate::connectImpl(const QObject *sender, int signal_index,
                                             const QObject *receiver, void **slot,
                                             QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type,
                                             const int *types, const QMetaObject *senderMetaObject)
{
    if (!sender || !receiver || !slotObj || !senderMetaObject) {
        const char *senderString = sender ? sender->metaObject()->className()
                                          : senderMetaObject ? senderMetaObject->className()
                                          : "Unknown";
        const char *receiverString = receiver ? receiver->metaObject()->className()
                                              : "Unknown";
        qWarning("QObject::connect(%s, %s): invalid nullptr parameter", senderString, receiverString);
        if (slotObj)
            slotObj->destroyIfLastRef();
        return QMetaObject::Connection();
    }

    QObject *s = const_cast<QObject *>(sender);
    QObject *r = const_cast<QObject *>(receiver);

    QOrderedMutexLocker locker(signalSlotLock(sender),
                               signalSlotLock(receiver));

    if (type & Qt::UniqueConnection && slot && QObjectPrivate::get(s)->connections.loadRelaxed()) {
        QObjectPrivate::ConnectionData *connections = QObjectPrivate::get(s)->connections.loadRelaxed();
        if (connections->signalVectorCount() > signal_index) {
            const QObjectPrivate::Connection *c2 = connections->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();

            while (c2) {
                if (c2->receiver.loadRelaxed() == receiver && c2->isSlotObject && c2->slotObj->compare(slot)) {
                    slotObj->destroyIfLastRef();
                    return QMetaObject::Connection();
                }
                c2 = c2->nextConnectionList.loadRelaxed();
            }
        }
        type = static_cast<Qt::ConnectionType>(type ^ Qt::UniqueConnection);
    }

    std::unique_ptr<QObjectPrivate::Connection> c{new QObjectPrivate::Connection};
    c->sender = s;
    c->signal_index = signal_index;
    QThreadData *td = r->d_func()->threadData;
    td->ref();
    c->receiverThreadData.storeRelaxed(td);
    c->receiver.storeRelaxed(r);
    c->slotObj = slotObj;
    c->connectionType = type;
    c->isSlotObject = true;
    if (types) {
        c->argumentTypes.storeRelaxed(types);
        c->ownArgumentTypes = false;
    }

    QObjectPrivate::get(s)->addConnection(signal_index, c.get());
    QMetaObject::Connection ret(c.release());
    locker.unlock();

    QMetaMethod method = QMetaObjectPrivate::signal(senderMetaObject, signal_index);
    Q_ASSERT(method.isValid());
    s->connectNotify(method);

    return ret;
}
```
QObject::connectImpl做了以下几件事：
- 信号指针是否存在；不存在报warning
- 从当前元对象开始，往上(父元对象)查找，直到找到信号的索引且没超出信号索引边界；没找到报warning
- 遍历所有祖先类（不包括当前类本身），累加父类的信号数量，signalOffset计算的是当前类的所有父类的信号总数，从而得到信号偏移量

# 事件系统

# 对象树

# 元对象系统
## QOBject设置属性
在QObject代码开头就用到了属性系统：
```cpp
Q_PROPERTY(QString objectName READ objectName WRITE setObjectName NOTIFY objectNameChanged)
```
要使用属性系统，必须继承QObject，而且在声明时用Q_PROPERTY宏。语法是：
```cpp
Q_PROPERTY(type name
           (READ getFunction [WRITE setFunction] |
            MEMBER memberName [(READ getFunction | WRITE setFunction)])
           [RESET resetFunction]
           [NOTIFY notifySignal]
           [REVISION int]
           [DESIGNABLE bool]
           [SCRIPTABLE bool]
           [STORED bool]
           [USER bool]
           [CONSTANT]
           [FINAL]
           [REQUIRED])
```
[]表示可选，getFunction和setFunction表示getter和setter函数，memberName表示成员变量，resetFunction表示重置函数，notifySignal表示通知信号，revision表示属性的版本，designable表示属性是否可设计，scriptable表示属性是否可脚本化，stored表示属性是否可存储，user表示属性是否是用户定义的，constant表示属性是否是常量，final表示属性是否是最终的，required表示属性是否是必须的。
举一个例子：
```cpp
class Widget : public QWidget
{
    Q_OBJECT
    //Q_PROPERTY(QString value1 READ value1 WRITE setValue1 NOTIFY value1Changed FINAL)
    Q_PROPERTY(int value2 MEMBER value2 READ getValue2 WRITE setValue2 NOTIFY value2Changed DESIGNABLE true FINAL)

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();

    void setValue2(int value){value2 = value;emit value2Changed(value);}
    int getValue2(){return value2;}

signals:
    void value2Changed(int);

private:
    Ui::Widget *ui;
    int value2  = 0;
};

//main
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    Widget w1;
    w1.setValue2(2);
    qDebug() << "w1-value2 = " << QString::number(w1.getValue2());
    w1.setProperty("value2", 100);
    qDebug() << "w1-value2 = " << QString::number(w1.property("value2").toInt());

    Widget w2;
    w2.setValue2(200);
    qDebug() << "w2-value2 = " << QString::number(w2.getValue2());
    w2.setProperty("value2", 2000);
    qDebug() << "w2-value2 = " << QString::number(w2.property("value2").toInt());

    w1.setProperty("value2", 500);
    qDebug() << "w1-value2 = " << QString::number(w1.property("value2").toInt());
    QMetaProperty value2 = w2.metaObject()->property(w2.metaObject()->indexOfProperty("value2"));
    qDebug() << value2.name();
    qDebug() << value2.typeName();

    return a.exec();
}

//输出：
// w1-value2 =  "2"
// w1-value2 =  "100"
// w2-value2 =  "200"
// w2-value2 =  "2000"
// w1-value2 =  "500"
// value2
// int
```
**具体官网有介绍。**


# 状态机框架

# 定时器

# 其他
## 三个宏定义
Q_DISABLE_COPY

Q_DISABLE_MOVE

Q_DISABLE_COPY_MOVE
```cpp
#define Q_DISABLE_COPY(Class) \
    Class(const Class &) = delete;\
    Class &operator=(const Class &) = delete;

#define Q_DISABLE_MOVE(Class) \
    Class(Class &&) = delete; \
    Class &operator=(Class &&) = delete;

#define Q_DISABLE_COPY_MOVE(Class) \
    Q_DISABLE_COPY(Class) \
    Q_DISABLE_MOVE(Class)
```
这三个宏定义感觉很不错，一般不允许copy和move通过删除或者声明为private，现在可以直接用Qt的这三个宏，不用手写。