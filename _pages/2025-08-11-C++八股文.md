---
title: C++八股文
author: 齐兆龙
date: 2025-08-11
category: C++
layout: post
---

---
# 1.C++面向对象编程的3大特性
- **封装**  

封装的意思是提供接口，隐藏实现细节，利用好封装可以解耦代码，提高可读性和便于维护，但实际开发初期，不要过度设计。

- **继承**  

派生类继承基类达到代码复用，如果可以抽象出一层来，并且有必要，可以抽象出基类。

- **多态**  

分为静态多态和动态多态：静态多态指的是重载，动态是通过关键字vritual声明虚函数，派生类重写，之所以叫动态是因为它在运行确定的，而重载是在编译时期就确定了。 

# 2.C++在继承时，基类和派生类是怎么做的
- **构造的时候，先构造基类在构造派生类**
- **析构的时候，先析构派生类再析构子类**   

想象着，如果在派生类的构造函数里用到了基类的成员变量，如果先构造派生类，那么此时基类是未被初始化的，所以是非法访问；同理析构也是如此。

# 3.如何解决多态情况下派生类无法析构的问题
将基类的析构函数设置为虚函数即可，一般有继承的情况下都设置为虚函数，当然这也会增加类大小。这是因为：

- **有虚函数所在的类，会生成一个虚函数表存储虚函数地址**
- **当实例化该类时，会隐式的添加一个虚指针指向虚函数表**
- **动态调用的时候，通过虚指针找到虚函数表从而找到对应的虚函数**
- **如果派生类重写了该虚函数，那么派生类的虚函数的地址覆盖了基类的地址，反之则还是基类的地址**  

从上面可知，类至少增加了一个指针的大小，而指针在内存是32/64位系统里就是32/64位，也就是4或者8个字节。

# 4.如何理解移动语义、浅拷贝和深拷贝
在C++中移动语义有两种：移动构造函数和移动赋值运算符。对对象的移动理解为：浅拷贝 + 置空原对象。也就是"窃取资源"。

**浅拷贝和深拷贝的区别主要是，对于指针或者引用成员变量，浅拷贝不拷贝指向的实际数据，原对象和新对象的两个成员变量指向的是同一地址；而深拷贝则会拷贝一份同样的数据，当需要资源的完全独立的时候就需要深拷贝**

# 5.拷贝构造函数和移动构造函数为啥需要用引用(&)和右值引用(&&)
因为加上引用和右值引用不需要创建临时对象，直接操作原对象，避免了无限递归

# 6.为什么需要移动语义
这个问题，我在网络编程的时候很费解，为什么io_context、socket和acceptor等不允许拷贝，所有我需要用`std::move()`去转移对象的控制权。老实说，我目前理解为两点：
- **性能优化，减少不必要的拷贝**
- **资源唯一性**

# 7.new/delete和malloc/free的区别
new和delete是C++的运算符，new先分配足够大的内存再调用构造函数，delete则是调用析构函数；malloc/free仅仅是申请/释放内存

# 8.const和static的作用
**const：**

- **定义常量**
- **修饰形参、返回值**
- **常量成员变量和常量成员函数**

**static：**

- **单例模式**
- **静态（全局/局部）变量**
- **静态成员变量和静态成员函数**

# 9.main()函数执行前的操作
main()会解析命令行的参数：
- **argc：argument count，表示字符串的数量**
- **argv：argument vector，表示的是一个二维数组，每个数组存储字符串，总共有argc个数组**  
例如："./a.exe -p -f -c"

    > **argc = 4**  
    > **argv[0] = ./a.exe**  
    > **argv[1] = -p**  
    > **argv[2] = -f**  
    > **argv[3] = -f**  

# 10.inline的要求
1.简单小型的函数

2.写在头文件的

3.写在头文件的类的函数默认内联

# 11.左值和右值表示什么
- **左值：表示长期存在的值(持久对象)，例如变量**
- **右值：表示即将消亡的临时值(临时对象)，例如返回值，一个数，表达式结果等**

# 12.C++11有哪些高级特性
**1.智能指针**

**2.自动推导（auto、decltype）**

**3右值引用和移动语义**

**4.范围for循环**

**5.多线程std::thread**

**6.Lambda表达式**

**7.原子操作std::atomic**

# 13.指针指针有哪些及其应用场景
**1.share_ptr：引用计数共享**

**2.unique_ptr：独占所有权**

**3.weak_ptr：配合share_ptr，解决循环引用的**

目前智能指针用得还不多，理解没那么深，以后再补充。

# 14.++i和i++的区别
++i是前置递增运算符，表示先自增1，再返回新值(次数已经加1了)；i++是后置递增运算符，表示先返回原值(未自增的值)，再进行自增1。\*(ptr++)和*(++ptr)的区别类型，前者解引用旧指针，后置解引用新指针。

# 15.静态全局变量和全局变量的区别
静态全局变量只能在当前文件使用，全局变量可以通过extern所有文件都可以使用。单例模式是通过公共静态方法，以及包含头文件可供所有文件使用。