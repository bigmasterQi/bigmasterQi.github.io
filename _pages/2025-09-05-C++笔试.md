---
title: C++笔试
author: 齐兆龙
date: 2025-09-05
category: C++
layout: post
---

---
# 1.bool、int、float、指针和0比较
`bool var = false; if(!var) {...}`

`int var = 1; if(var == 0) {...}`

`float var = 0.0f; if(std::abs(f) < 1e-6) {...}`

`int* p = 1; if(var == nullptr) {...}`

# 2.写出下列字节数
```cpp
char carry[100] = "Hello World";
char *pstr = "Hello World";
Base b1;

int Base::SizeOf(char p[])
{
    return sizeof(p);
}

int Base::SizeOf2(char *p)
{
    return sizeof(p);
}
```

sizeof(carry) ---     **100**

sizeof(pstr)  ---     **4/8**

sizeof(*pstr)   ---   **1**

b1.SizeOf(carry) ---  **4/8**

b1.SizeOf2(carry) --- **4/8**

carry[100],返回的是数组总大小，而char在计算中中是一个字节；pstr是指针，指针在64位系统或者32位系统中是8或4个字节；*pstr是指针指向的第一个char类型元素，为1个字节；char p[]退化为指针，和SizeOf2一样的，8或4个字节。

# 3.int a = 3; int b = a << 3;a和b等于多少？
左移n位相当于乘以2的n次方，右移n位相当于除以2的n次方并向下取整（考虑负数，负数向负无穷方向）。负数的二进制为原码取反后最低位+1。

例如 a = 0000 0011，左移3位后为0001 1000(16+8=24)(3*8=24)。假设有12 = 0000 1100，原码取反后+1得到：-12 = 1111 0100，右移2位为1111 1101。反推回去，先-1得到1111 1100，再取反0000 0011(3)；如果按照规律直接计算是-12/4 = -3。

# 4.在32位系统中，char类型占多少字节？int、short、long以及指针呢？64位系统呢？
大多数机器一个字节是由8个bit组成：
| 类型 |  bit | 32位 | 64位 |
|------|------|------|------|
| char |  8bit | 1字节   | 1字节 |
| int |  32bit | 4字节   | 4字节 |
| short |  16bit | 2字节   | 2字节 |
| long |  32bit | 4字节   | 4字节 |
| 指针 |  32/64bit | 4字节   | 8字节 |
| float |  32bit | 4字节   | 4字节 |
| double |  64bit | 8字节   | 8字节 |

# 5.写一个标准宏或者模板，返回较小的那个
宏：

`#define MIN(a,b) ((a) < (b)? (a) : (b))`

模板：
```cpp
template<typename T>
const T& min(const T& a, const T& b){
    return (a < b)? a : b;
}
```
# 6.写一个算法对1，8，5，2，4，9，7，6，3，0进行顺序排列
使用快速排序，运用双指针和递归
```cpp
void quickSort1(std::vector& nums, int left, int right)
{
    if(left >= right)
        return;

    int pivot = nums[left + (right-left)/2];
    int i = left, j = right;
    while(i <= j)
    {
        while(num[i] < pivot) i++;
        while(num[j] > pivot) j--;
        if(i <= j)
        {
            std::swap(num[i], num[j]);
            i++;
            j--;
        }
    }

    quickSort(nums, left, j);
    quickSort(nums, i, right);
}

下面是i==j情况下不交换的，AI验证可行，实际不清楚
void quickSort2(std::vector& nums, int left, int right)
{
    if(left >= right)
        return;

    int pivot = nums[left + (right-left)/2];
    int i = left, j = right;
    while(i < j) //i==j的时候退出
    {
        while(num[i] < pivot) i++;
        while(num[j] > pivot) j--;
        if(i < j)
        {
            std::swap(num[i], num[j]);
            i++;
            j--;
        }
    }
    //相比较之前少交换一次，既然i==j==基准，那么就去掉基准值，分左右两边递归

    quickSort(nums, left, i-1);
    quickSort(nums, j+1, right);
}
```

# 7.如何区分本机字节序
**小端序(低字节存低地址)：**  
地址：　　低地址 → 高地址  
字节：　　0x01　　0x00　　0x00　　0x00  
　　　　　↑  
　　　　　char*指针指向这里，值为1

**大端序(高字节存低地址)：**  
地址：　　低地址 → 高地址  
字节：　　0x00　　0x00　　0x00　　0x01  
　　　　　↑  
　　　　　char*指针指向这里，值为0
```cpp
//&num：获取num的地址（int*类型）
//(char*)&num：强制转换为char*类型（指向第一个字节）
//*(char*)&num：解引用，得到第一个字节的值
//大多数现代计算机（x86、x86-64架构）都是小端序，而网络字节序通常是大端序。
bool is_big_endian() {
    int num = 1；
    if(*(char*)&num == 1)
    {
        Return “小端序”；
    }
    else
    {
        Return “大端序”；
    }

}
```

# 8.一种线程安全的单例模式（多线程模式）
## C++ 11之后，static局部变量线程安全，可以用梅耶单例
```cpp
static T& GetInstanc(){
    static T m_instance;
    return m_instance;
}
```
## 单例模板
```cpp
template <typename T>
class singleton
{

protected:
    singleton() = default;
    singleton(const singleton& other) = delete;
    singleton& operator=(const singleton& other) = delete;

public:
    static T& instance()
    {
        static T ins;
        return ins;
    }

    virtual ~singleton() = default;

};

//继承时,friend class singleton<A>; 是为了让基类模板能够访问派生类的私有构造函数(默认)，从而完成单例对象的创建。这是CRTP（奇异递归模板模式）中常见的技巧。
class A : public singleton<A>
{
    friend class singleton<A>;
};
```